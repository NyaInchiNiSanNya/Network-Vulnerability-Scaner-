using FluentValidation;
using Network_Vulnerability_Scaner.Application.Models.Requests_Responses;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Network_Vulnerability_Scaner.Application.Models.Dto;
using Network_Vulnerability_Scaner.Domain.Constants;
using System.Reflection;

namespace Network_Vulnerability_Scaner.Application.Validators
{
    public class NetworkToScanDtoValidator : AbstractValidator<NetworkToScanDto>
    {
        public NetworkToScanDtoValidator()
        {
            RuleFor(x => x.Ip)
                .NotEmpty().WithMessage("Empty ip")
                .Matches(
                    "^(?:\\d{1,3}\\.){3}\\d{1,3}(?:-\\d{1,3})?$");

            RuleFor(x => x.Ports)
                .ForEach(port
                    => port.Must(IsValidPorts));

            RuleFor(x => x.TcpScanMethod)
                .Must(IsValidMethod);

        }

        private Boolean IsValidPorts(Int32 port)
        {
            if (port > 0)
            {
                return true;
            }

            return false;
        }

        private Boolean IsValidMethod(String? tcpScanMethod)
        {
            if (tcpScanMethod == null)
            {
                return true;
            }

            Type scanMethodsType = typeof(ScanMethods);
            FieldInfo[] constants = scanMethodsType.GetFields(BindingFlags.Static
                                                              | BindingFlags.Public
                                                              | BindingFlags.FlattenHierarchy).ToArray();

            foreach (var method in constants)
            {
                if (method.GetValue(null).Equals(tcpScanMethod))
                {
                    return true;
                }
            }

            return false;
        }
    }
}
