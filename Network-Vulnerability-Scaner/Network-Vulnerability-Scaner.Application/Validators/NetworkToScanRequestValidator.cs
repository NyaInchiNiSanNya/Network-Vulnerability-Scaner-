using FluentValidation;
using Network_Vulnerability_Scaner.Application.Models.Requests_Responses;
using Network_Vulnerability_Scaner.Domain.Constants;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;

namespace Network_Vulnerability_Scaner.Application.Validators
{
    public class NetworkToScanRequestValidator : AbstractValidator<NetworkToScanRequest>
    {
        public NetworkToScanRequestValidator()
        {
            RuleFor(x => x.Ip)
                .NotEmpty().WithMessage("Empty ip")
                .Matches(
                    "^(?:\\d{1,3}\\.){3}\\d{1,3}(?:-\\d{1,3})?$").WithMessage("Valid Ip: x.x.x.x or x.x.x.x-x");

            RuleFor(x => x.Ports)
                .Must(IsValidPorts).WithMessage("Incorrect ports ");

            RuleFor(x => x.TcpScanMethod)
                .Must(IsValidMethod).WithMessage("Incorrect tcp scan method");

        }

        private Boolean IsValidPorts(String port)
        {
            var portsList = port.Split().ToList();

            foreach (var portString in portsList)
            {
                if (!Int32.TryParse(portString, out int result))
                {
                    return false;
                }
            }

            return true;
        }

        private Boolean IsValidMethod(String? tcpScanMethod)
        {
            if (tcpScanMethod == null)
            {
                return true;
            }

            Type scanMethodsType = typeof(ScanMethods);
            FieldInfo[] constants = scanMethodsType.GetFields(BindingFlags.Static 
                                                              | BindingFlags.Public 
                                                              | BindingFlags.FlattenHierarchy).ToArray();

            foreach (var method in constants)
            {
                if (method.GetValue(null).Equals(tcpScanMethod))
                {
                    return true;
                }
            }
            
            return false;
        }
    }
}
