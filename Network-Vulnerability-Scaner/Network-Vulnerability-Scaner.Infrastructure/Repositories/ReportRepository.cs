using Amazon.Runtime.Internal;
using AutoMapper;
using MongoDB.Driver;
using Network_Vulnerability_Scaner.Application.Interfaces.Repositories;
using Network_Vulnerability_Scaner.Application.Models.Dto;
using Network_Vulnerability_Scaner.Infrastructure.Data;
using Network_Vulnerability_Scaner.Infrastructure.Models;
using System.Security.Principal;
using System.Threading;

namespace Network_Vulnerability_Scaner.Infrastructure.Repository
{
    internal class ReportRepository:IReportRepository
    {
        private readonly IMongoCollection<ScanReport> _reports;
        private readonly IMapper _mapper;

        public ReportRepository(IReportsDBSettings settings
            , IMongoClient mongoClient
            ,IMapper mapper)
        {
            var x = settings.DatabaseName;
            var database = mongoClient.GetDatabase(settings.DatabaseName);
            _reports = database.GetCollection<ScanReport>(settings.ReportsCollectionName);

            _mapper = mapper ?? throw new NullReferenceException(nameof(mapper));
        }

        public async Task AddReportAsync(ScanReportDto reportDto)
        {
            await _reports.InsertOneAsync(_mapper.Map<ScanReport>(reportDto));
        }

        public async Task<List<ShortDiscReportDto>> GetAllReportsAsync()
        {
            var jrep = await _reports.Find(_ => true).ToListAsync();
            
            var documents = _mapper.Map<List<ShortDiscReportDto>>(jrep);
            
            return documents;
        }

        public async Task<ScanReportDto> GetReportByIdAsync(String id)
        {
            if (String.IsNullOrEmpty(id))
            {
                throw new ArgumentNullException(nameof(id));
            }

            var filter = Builders<ScanReport>.Filter.Eq(account => account.ReportId, id);

            return _mapper.Map<ScanReportDto>(await _reports.Find(filter).FirstOrDefaultAsync());

        }
    }
}
