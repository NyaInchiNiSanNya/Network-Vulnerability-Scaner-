using Docker.DotNet.Models;
using Network_Vulnerability_Scaner.Domain.Entities;
using Network_Vulnerability_Scaner.Domain.Interfaces.Internal;
using SharpCifs.Smb;
using Port = Network_Vulnerability_Scaner.Domain.Entities.Port;

namespace Network_Vulnerability_Scaner.Domain.Services.MissConfigurationServices
{
    internal class SMBservice : ISmbService
    {

        public async Task<String> AnonymousCheckAsync(Port port, String ipAddress)
        {
            String smbServerUrl = $"smb://{ipAddress}:{port.PortNumber}/";

            try
            {
                NtlmPasswordAuthentication auth = NtlmPasswordAuthentication.Anonymous;

                SmbFile smbFile = new SmbFile(smbServerUrl, auth);

                if (smbFile.IsDirectory())
                {
                    return "Anonymous access allowed to directory." + "\n";
                }
                else
                {
                    return "Anonymous access allowed to file." + "\n";
                }
            }
            catch (Exception ex)
            {
                return "Access denied or error occurred:" +ex.Message + "\n";
            }
        }

        public async Task<String> NullSessionCheckAsync(Port port, String ipAddress)
        {
            String smbServerUrl = $"smb://{ipAddress}:{port.PortNumber}/";

            try
            {
                NtlmPasswordAuthentication auth = new NtlmPasswordAuthentication("", "", "");

                SmbFile smbFile = new SmbFile(smbServerUrl, auth);

                SmbFileInputStream inputStream = new SmbFileInputStream(smbFile);
                
                inputStream.Close(); 

                return "Null Session is allowed." + "\n";
            }
            catch (SmbAuthException ex)
            {
                return $"Authentication failed: {ex.Message}" + "\n";
            }
        }
    }
}
