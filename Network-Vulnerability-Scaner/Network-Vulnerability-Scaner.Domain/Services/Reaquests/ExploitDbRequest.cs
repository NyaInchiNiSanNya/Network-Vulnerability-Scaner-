using Network_Vulnerability_Scaner.Domain.Entities;
using System.Diagnostics;
using System.Text.RegularExpressions;
using static System.Net.WebRequestMethods;

namespace Network_Vulnerability_Scaner.Domain.Services.Reaquests
{
    internal class ExploitDbRequest
    {
        internal async Task<List<ExploitDbVulnerability>> RequestToExploitDb(String requestString)
        {
            var searchReport = await ExploitsSearch(requestString);

            var edbIds = SearchReportReader(searchReport).ToList();

            List<ExploitDbVulnerability> exploits =
                new List<ExploitDbVulnerability>();

            foreach (var exploitId in edbIds)
            {
                var exploitReport = await GetInformationAboutExploitAsync(exploitId);

                if (!String.IsNullOrEmpty(exploitReport))
                {
                    exploits.Add(ExploitReportReader(exploitReport, exploitId));
                }
            }

            return exploits;
        }

        private IEnumerable<String> SearchReportReader(String report)
        {
            String[] lines = report.Split('\n', StringSplitOptions.RemoveEmptyEntries);

            List<String> edbIds = new List<String>();

            foreach (String line in lines)
            {
                String[] parts = line.Split('|', StringSplitOptions.RemoveEmptyEntries);

                if (parts.Length >= 2)
                {
                    if (Int32.TryParse(parts[1].Trim(), out int result))
                    {
                        String edbId = parts[1].Trim();
                        edbIds.Add(edbId);
                    }
                }
            }

            return edbIds;
        }

        private ExploitDbVulnerability ExploitReportReader(String report, String id)
        {
            var exploit = new ExploitDbVulnerability
            {
                ExploitTitle = GetMatchValue(report, "Exploit: (.+)"),
                URL = GetMatchValue(report, "URL: (.+)"),
                Codes = GetMatchValue(report, "Codes: (.+)"),
                DownloadExp = @"https://www.exploit-db.com/download/"+id,
                Verified = Boolean.Parse(GetMatchValue(report, "Verified: (.+)")),
                FileType = GetMatchValue(report, "File Type: (.+)")
            };

            return exploit;
        }

        private static String GetMatchValue(String input, String pattern)
        {
            Match match = Regex.Match(input, pattern);

            return match.Success ? match.Groups[1].Value : "";
        }

        private async Task<String> ExploitsSearch(String request)
        {
            String containerId = "bdc56a408485";
            String command = $"searchsploit --id {request}";

            Process process = new Process();
            process.StartInfo.FileName = "docker";
            process.StartInfo.Arguments = $"exec -it {containerId} {command}";
            process.StartInfo.UseShellExecute = false;
            process.StartInfo.RedirectStandardOutput = true;
            process.StartInfo.RedirectStandardError = true;

            process.Start();

            String output = await process.StandardOutput.ReadToEndAsync();
            String error = await process.StandardError.ReadToEndAsync();

            await process.WaitForExitAsync();

            process.Close();

            if (!String.IsNullOrEmpty(error))
            {
                throw new InvalidOperationException(error);
            }

            return output;
        }

        private async Task<String?> GetInformationAboutExploitAsync(String exploitId)
        {
            String containerId = "bdc56a408485";

            String command = $"searchsploit -p {exploitId}";

            Process process = new Process();
            process.StartInfo.FileName = "docker";
            process.StartInfo.Arguments = $"exec -it {containerId} {command}";
            process.StartInfo.UseShellExecute = false;
            process.StartInfo.RedirectStandardOutput = true;
            process.StartInfo.RedirectStandardError = true;

            process.Start();

            String? output = await process.StandardOutput.ReadToEndAsync();
            String error = await process.StandardError.ReadToEndAsync();

            await process.WaitForExitAsync();

            process.Close();

            if (!String.IsNullOrEmpty(error))
            {
                return null;
            }

            return output;
        }
    }
}
