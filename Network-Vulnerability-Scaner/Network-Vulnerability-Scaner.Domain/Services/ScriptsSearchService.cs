using Network_Vulnerability_Scaner.Domain.Entities;
using Network_Vulnerability_Scaner.Domain.Interfaces;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;

namespace Network_Vulnerability_Scaner.Domain.Services
{
    public class ScriptsSearchService : IScriptsSearchService
    {

        
        public async Task<IEnumerable<Script>> GetAllScriptsAsync()
        {
            string arguments = "--script-help all";

            String scriptsOutput = "";

            ProcessStartInfo psi = new ProcessStartInfo
            {
                FileName = "nmap",
                Arguments = arguments,
                RedirectStandardOutput = true,
                UseShellExecute = false,
                CreateNoWindow = true
            };

            using (Process process = new Process { StartInfo = psi })
            {
                process.Start();

                scriptsOutput = await process.StandardOutput.ReadToEndAsync();

                await process.WaitForExitAsync();
            }

            Regex regex = new Regex(@"^\s*([\w-]+)\s*$", RegexOptions.Multiline);

            MatchCollection matches = regex.Matches(scriptsOutput);

            List<string> scriptNames = new List<string>();

            foreach (Match match in matches)
            {
                string scriptName = match.Groups[1].Value;
                scriptNames.Add(scriptName);
            }

            List<Script> processedScripts = await ProcessScriptNamesAsync(scriptNames);


            return processedScripts;
        }

        public async Task<List<Script>> ProcessScriptNamesAsync(List<string> scriptNames)
        {
            List<Script> scripts = new List<Script>();

            List<Task<string>> scriptTasks = new List<Task<string>>();

            foreach (string scriptName in scriptNames)
            {
                Task<string> scriptOutputTask = GetScriptHelpOutput(scriptName);
                scriptTasks.Add(scriptOutputTask);
            }
            await Task.WhenAll(scriptTasks);

            for (int i = 0; i < scriptNames.Count; i++)
            {
                string scriptName = scriptNames[i];
                string scriptOutput = scriptTasks[i].Result;

                if (!string.IsNullOrEmpty(scriptOutput))
                {
                    string description = ExtractScriptDescription(scriptOutput, scriptName);

                    Script script = new Script
                    {
                        Name = scriptName,
                        Description = description
                    };

                    scripts.Add(script);
                }
            }

            return scripts;
        }

        static async Task<string> GetScriptHelpOutput(string scriptName)
        {
            string command = "nmap";
            string arguments = $"--script-help {scriptName}";

            using (Process process = new Process())
            {
                process.StartInfo.FileName = command;
                process.StartInfo.Arguments = arguments;
                process.StartInfo.RedirectStandardOutput = true;
                process.StartInfo.UseShellExecute = false;
                process.StartInfo.CreateNoWindow = true;

                process.Start();

                string output = await process.StandardOutput.ReadToEndAsync();

                process.WaitForExit();

                return output;
            }
        }

        static string ExtractScriptDescription(string scriptOutput, string scriptName)
        {
            Regex regex = new Regex($@"^{scriptName}\s*([\s\S]*)", RegexOptions.Multiline);
            Match match = regex.Match(scriptOutput);

            if (match.Success)
            {
                return match.Groups[1].Value.Trim();
            }

            return string.Empty;
        }

        public Task<IEnumerable<Script>> GetScriptsByServiceAsync(string serviceName)
        {
            throw new NotImplementedException();
        }
    }
}
